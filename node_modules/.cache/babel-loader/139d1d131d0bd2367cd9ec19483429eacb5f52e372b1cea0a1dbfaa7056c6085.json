{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\homel\\\\Downloads\\\\alb math program\\\\src\\\\components\\\\LatexText.js\";\nimport React from 'react';\nimport 'katex/dist/katex.min.css';\nimport { BlockMath, InlineMath } from 'react-katex';\n\n// Render a string that may include inline $...$ or block $$...$$ math.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function LatexText({\n  text\n}) {\n  if (!text && text !== 0) return null;\n  const parts = [];\n  const regex = /(\\$\\$[^$]+\\$\\$|\\$[^$]+\\$)/g;\n  let lastIndex = 0;\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    const idx = match.index;\n    if (idx > lastIndex) {\n      parts.push({\n        type: 'text',\n        content: text.slice(lastIndex, idx)\n      });\n    }\n    const token = match[0];\n    if (token.startsWith('$$')) {\n      parts.push({\n        type: 'block',\n        content: token.slice(2, -2)\n      });\n    } else {\n      parts.push({\n        type: 'inline',\n        content: token.slice(1, -1)\n      });\n    }\n    lastIndex = idx + token.length;\n  }\n  if (lastIndex < text.length) parts.push({\n    type: 'text',\n    content: text.slice(lastIndex)\n  });\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    children: parts.map((p, i) => {\n      if (p.type === 'text') return /*#__PURE__*/_jsxDEV(\"span\", {\n        children: p.content\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 30,\n        columnNumber: 39\n      }, this);\n      if (p.type === 'inline') return /*#__PURE__*/_jsxDEV(InlineMath, {\n        math: p.content\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 31,\n        columnNumber: 41\n      }, this);\n      return /*#__PURE__*/_jsxDEV(BlockMath, {\n        math: p.content\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 32,\n        columnNumber: 16\n      }, this);\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 28,\n    columnNumber: 5\n  }, this);\n}\n_c = LatexText;\nvar _c;\n$RefreshReg$(_c, \"LatexText\");","map":{"version":3,"names":["React","BlockMath","InlineMath","jsxDEV","_jsxDEV","LatexText","text","parts","regex","lastIndex","match","exec","idx","index","push","type","content","slice","token","startsWith","length","children","map","p","i","fileName","_jsxFileName","lineNumber","columnNumber","math","_c","$RefreshReg$"],"sources":["C:/Users/homel/Downloads/alb math program/src/components/LatexText.js"],"sourcesContent":["import React from 'react';\r\nimport 'katex/dist/katex.min.css';\r\nimport { BlockMath, InlineMath } from 'react-katex';\r\n\r\n// Render a string that may include inline $...$ or block $$...$$ math.\r\nexport default function LatexText({ text }) {\r\n  if (!text && text !== 0) return null;\r\n  const parts = [];\r\n  const regex = /(\\$\\$[^$]+\\$\\$|\\$[^$]+\\$)/g;\r\n  let lastIndex = 0;\r\n  let match;\r\n  while ((match = regex.exec(text)) !== null) {\r\n    const idx = match.index;\r\n    if (idx > lastIndex) {\r\n      parts.push({ type: 'text', content: text.slice(lastIndex, idx) });\r\n    }\r\n    const token = match[0];\r\n    if (token.startsWith('$$')) {\r\n      parts.push({ type: 'block', content: token.slice(2, -2) });\r\n    } else {\r\n      parts.push({ type: 'inline', content: token.slice(1, -1) });\r\n    }\r\n    lastIndex = idx + token.length;\r\n  }\r\n  if (lastIndex < text.length) parts.push({ type: 'text', content: text.slice(lastIndex) });\r\n\r\n  return (\r\n    <span>\r\n      {parts.map((p, i) => {\r\n        if (p.type === 'text') return <span key={i}>{p.content}</span>;\r\n        if (p.type === 'inline') return <InlineMath key={i} math={p.content} />;\r\n        return <BlockMath key={i} math={p.content} />;\r\n      })}\r\n    </span>\r\n  );\r\n}\r\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAO,0BAA0B;AACjC,SAASC,SAAS,EAAEC,UAAU,QAAQ,aAAa;;AAEnD;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,eAAe,SAASC,SAASA,CAAC;EAAEC;AAAK,CAAC,EAAE;EAC1C,IAAI,CAACA,IAAI,IAAIA,IAAI,KAAK,CAAC,EAAE,OAAO,IAAI;EACpC,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,KAAK,GAAG,4BAA4B;EAC1C,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,KAAK;EACT,OAAO,CAACA,KAAK,GAAGF,KAAK,CAACG,IAAI,CAACL,IAAI,CAAC,MAAM,IAAI,EAAE;IAC1C,MAAMM,GAAG,GAAGF,KAAK,CAACG,KAAK;IACvB,IAAID,GAAG,GAAGH,SAAS,EAAE;MACnBF,KAAK,CAACO,IAAI,CAAC;QAAEC,IAAI,EAAE,MAAM;QAAEC,OAAO,EAAEV,IAAI,CAACW,KAAK,CAACR,SAAS,EAAEG,GAAG;MAAE,CAAC,CAAC;IACnE;IACA,MAAMM,KAAK,GAAGR,KAAK,CAAC,CAAC,CAAC;IACtB,IAAIQ,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MAC1BZ,KAAK,CAACO,IAAI,CAAC;QAAEC,IAAI,EAAE,OAAO;QAAEC,OAAO,EAAEE,KAAK,CAACD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;MAAE,CAAC,CAAC;IAC5D,CAAC,MAAM;MACLV,KAAK,CAACO,IAAI,CAAC;QAAEC,IAAI,EAAE,QAAQ;QAAEC,OAAO,EAAEE,KAAK,CAACD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;MAAE,CAAC,CAAC;IAC7D;IACAR,SAAS,GAAGG,GAAG,GAAGM,KAAK,CAACE,MAAM;EAChC;EACA,IAAIX,SAAS,GAAGH,IAAI,CAACc,MAAM,EAAEb,KAAK,CAACO,IAAI,CAAC;IAAEC,IAAI,EAAE,MAAM;IAAEC,OAAO,EAAEV,IAAI,CAACW,KAAK,CAACR,SAAS;EAAE,CAAC,CAAC;EAEzF,oBACEL,OAAA;IAAAiB,QAAA,EACGd,KAAK,CAACe,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MACnB,IAAID,CAAC,CAACR,IAAI,KAAK,MAAM,EAAE,oBAAOX,OAAA;QAAAiB,QAAA,EAAeE,CAAC,CAACP;MAAO,GAAbQ,CAAC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAmB,CAAC;MAC9D,IAAIL,CAAC,CAACR,IAAI,KAAK,QAAQ,EAAE,oBAAOX,OAAA,CAACF,UAAU;QAAS2B,IAAI,EAAEN,CAAC,CAACP;MAAQ,GAAnBQ,CAAC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAoB,CAAC;MACvE,oBAAOxB,OAAA,CAACH,SAAS;QAAS4B,IAAI,EAAEN,CAAC,CAACP;MAAQ,GAAnBQ,CAAC;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAoB,CAAC;IAC/C,CAAC;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACE,CAAC;AAEX;AAACE,EAAA,GA9BuBzB,SAAS;AAAA,IAAAyB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}